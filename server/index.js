import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import algosdk from 'algosdk';
import crypto from 'crypto';
import twilio from 'twilio';
import sgMail from '@sendgrid/mail';

const app = express();
const PORT = 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Network configurations
const NETWORK_CONFIGS = {
  testnet: {
    name: 'TestNet',
    algodToken: '',
    algodServer: 'https://testnet-api.4160.nodely.dev',
    algodPort: 443
  },
  mainnet: {
    name: 'MainNet',
    algodToken: '',
    algodServer: 'https://mainnet-api.4160.nodely.dev',
    algodPort: 443
  }
};

// Create Algorand client for specific network
function createAlgodClient(network = 'testnet') {
  const config = NETWORK_CONFIGS[network];
  if (!config) {
    throw new Error(`Unsupported network: ${network}`);
  }
  
  return new algosdk.Algodv2(config.algodToken, config.algodServer, config.algodPort);
}

// Initialize Twilio client only if valid credentials are provided
let twilioClient = null;
const twilioAccountSid = process.env.TWILIO_ACCOUNT_SID;
const twilioAuthToken = process.env.TWILIO_AUTH_TOKEN;
const twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER;

// Check if Twilio credentials are valid (not placeholder values)
const isValidTwilioConfig = 
  twilioAccountSid && 
  twilioAuthToken && 
  twilioPhoneNumber &&
  twilioAccountSid.startsWith('AC') &&
  twilioAccountSid !== 'your_twilio_account_sid' &&
  twilioAuthToken !== 'your_twilio_auth_token' &&
  twilioPhoneNumber !== 'your_twilio_phone_number';

if (isValidTwilioConfig) {
  try {
    twilioClient = twilio(twilioAccountSid, twilioAuthToken);
    console.log('‚úÖ Twilio client initialized successfully');
  } catch (error) {
    console.warn('‚ö†Ô∏è Failed to initialize Twilio client:', error.message);
    console.log('üì± SMS notifications will be simulated');
  }
} else {
  console.log('üì± Twilio not configured - SMS notifications will be simulated');
}

// Initialize SendGrid client only if valid credentials are provided
const sendGridApiKey = process.env.SENDGRID_API_KEY;
const sendGridFromEmail = process.env.SENDGRID_FROM_EMAIL;

const isValidSendGridConfig = 
  sendGridApiKey && 
  sendGridFromEmail &&
  sendGridApiKey !== 'your_sendgrid_api_key' &&
  sendGridFromEmail !== 'noreply@randcash.app';

if (isValidSendGridConfig) {
  try {
    sgMail.setApiKey(sendGridApiKey);
    console.log('‚úÖ SendGrid client initialized successfully');
  } catch (error) {
    console.warn('‚ö†Ô∏è Failed to initialize SendGrid client:', error.message);
    console.log('üìß Email notifications will be simulated');
  }
} else {
  console.log('üìß SendGrid not configured - Email notifications will be simulated');
}

// Generate secure random claim code
function generateClaimCode() {
  return crypto.randomBytes(16).toString('hex').toUpperCase();
}

// Hash claim code for smart contract
function hashClaimCode(code) {
  return crypto.createHash('sha256').update(code).digest();
}

// Create PyTEAL-based escrow contract
function createEscrowContractTeal(hashedClaimCode, recipientHash, amount) {
  // This is a simplified TEAL program that would be generated by PyTEAL
  // In production, you'd use PyTEAL to generate this programmatically
  const tealProgram = `#pragma version 8

// This is an escrow contract that holds funds until claimed with correct code
// Global state: 
// - "claim_hash": the hashed claim code
// - "amount": the amount to be claimed
// - "claimed": whether funds have been claimed

txn TypeEnum
int appl // ApplicationCall
==
bnz handle_app_call

// Handle payment transactions
txn TypeEnum
int pay
==
bnz handle_payment

// Reject other transaction types
int 0
return

handle_payment:
// Allow funding the contract
txn Receiver
global CurrentApplicationAddress
==
assert
int 1
return

handle_app_call:
// Check application call method
txn ApplicationArgs 0
byte "claim"
==
bnz handle_claim

txn ApplicationArgs 0
byte "setup"
==
bnz handle_setup

// Default reject
int 0
return

handle_setup:
// Initialize the contract with claim hash
txn ApplicationArgs 1
len
int 32
==
assert

// Store the claim hash
byte "claim_hash"
txn ApplicationArgs 1
app_global_put

// Store the amount
byte "amount"
txn ApplicationArgs 2
btoi
app_global_put

// Mark as not claimed
byte "claimed"
int 0
app_global_put

int 1
return

handle_claim:
// Verify claim code hash
txn ApplicationArgs 1
len
int 32
==
assert

// Check if already claimed
byte "claimed"
app_global_get
int 0
==
assert

// Verify the claim code hash matches
byte "claim_hash"
app_global_get
txn ApplicationArgs 1
==
assert

// Mark as claimed
byte "claimed"
int 1
app_global_put

// Transfer funds to claimer
itxn_begin
int pay
itxn_field TypeEnum
txn Sender
itxn_field Receiver
byte "amount"
app_global_get
itxn_field Amount
itxn_submit

int 1
return`;

  return tealProgram;
}

// Compile TEAL program
async function compileTealProgram(tealSource, network = 'testnet') {
  try {
    const algodClient = createAlgodClient(network);
    const compileResponse = await algodClient.compile(tealSource).do();
    return {
      compiledProgram: new Uint8Array(Buffer.from(compileResponse.result, 'base64')),
      hash: compileResponse.hash
    };
  } catch (error) {
    console.error('Error compiling TEAL program:', error);
    throw new Error('Failed to compile smart contract');
  }
}

// Deploy smart contract to Algorand
async function deployContract(compiledProgram, senderAddress, claimHash, amount, network = 'testnet') {
  try {
    const algodClient = createAlgodClient(network);
    const suggestedParams = await algodClient.getTransactionParams().do();
    
    // Create application creation transaction
    const appCreateTxn = algosdk.makeApplicationCreateTxnFromObject({
      from: senderAddress,
      suggestedParams,
      approvalProgram: compiledProgram,
      clearProgram: new Uint8Array([0x06, 0x81, 0x01]), // Simple clear program
      numLocalInts: 0,
      numLocalByteSlices: 0,
      numGlobalInts: 2, // amount, claimed
      numGlobalByteSlices: 1, // claim_hash
      appArgs: [
        new TextEncoder().encode('setup'),
        claimHash,
        algosdk.encodeUint64(amount * 1000000) // Convert ALGO to microAlgos
      ]
    });

    return {
      transaction: appCreateTxn,
      txId: appCreateTxn.txID()
    };
  } catch (error) {
    console.error('Error creating contract deployment transaction:', error);
    throw new Error('Failed to create contract deployment transaction');
  }
}

// Send notification via SMS or Email
async function sendNotification(recipient, claimCode, amount, message, network = 'testnet') {
  const isEmail = recipient.includes('@');
  const networkName = NETWORK_CONFIGS[network].name;
  const notificationMessage = `You've received ${amount} ALGO on RandCash (${networkName})! ${message ? `Message: "${message}"` : ''} Use claim code: ${claimCode} to claim your funds.`;

  try {
    if (isEmail) {
      // Send email via SendGrid
      if (!isValidSendGridConfig) {
        console.log(`üìß [SIMULATED EMAIL] To: ${recipient}: ${notificationMessage}`);
        return { success: true, method: 'email_simulation' };
      }

      const msg = {
        to: recipient,
        from: sendGridFromEmail,
        subject: `You've received ${amount} ALGO on RandCash (${networkName})!`,
        text: notificationMessage,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <h2 style="color: #2563eb;">You've received ${amount} ALGO!</h2>
            <p>Someone sent you cryptocurrency using RandCash on Algorand ${networkName}.</p>
            ${message ? `<p><strong>Message:</strong> "${message}"</p>` : ''}
            <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin: 20px 0;">
              <p><strong>Your claim code:</strong></p>
              <p style="font-family: monospace; font-size: 18px; font-weight: bold; color: #1f2937; background: white; padding: 10px; border-radius: 4px;">${claimCode}</p>
            </div>
            <p>Visit RandCash to claim your funds by entering this code and connecting your wallet.</p>
            <p style="color: #6b7280; font-size: 12px;">Network: Algorand ${networkName}</p>
          </div>
        `
      };

      await sgMail.send(msg);
      return { success: true, method: 'email' };
    } else {
      // Send SMS via Twilio
      if (!isValidTwilioConfig) {
        console.log(`üì± [SIMULATED SMS] To: ${recipient}: ${notificationMessage}`);
        return { success: true, method: 'sms_simulation' };
      }

      await twilioClient.messages.create({
        body: notificationMessage,
        from: twilioPhoneNumber,
        to: recipient
      });
      return { success: true, method: 'sms' };
    }
  } catch (error) {
    console.error('Error sending notification:', error);
    // Don't fail the entire transaction if notification fails
    return { success: false, error: error.message, method: isEmail ? 'email' : 'sms' };
  }
}

// API endpoint to create claim
app.post('/api/create-claim', async (req, res) => {
  try {
    const { amount, recipient, message, senderAddress, network = 'testnet' } = req.body;

    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }

    // Validate input
    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Invalid amount' });
    }
    
    if (!recipient || !recipient.trim()) {
      return res.status(400).json({ error: 'Recipient is required' });
    }
    
    if (!senderAddress) {
      return res.status(400).json({ error: 'Sender address is required' });
    }

    // Validate sender address format
    if (!algosdk.isValidAddress(senderAddress)) {
      return res.status(400).json({ error: 'Invalid sender address' });
    }

    // Additional validation for MainNet
    if (network === 'mainnet' && amount > 10) {
      return res.status(400).json({ error: 'Maximum amount on MainNet is 10 ALGO for safety' });
    }

    console.log(`Creating claim for ${amount} ALGO from ${senderAddress} to ${recipient} on ${NETWORK_CONFIGS[network].name}`);

    // Generate claim code and hash it
    const claimCode = generateClaimCode();
    const hashedClaimCode = hashClaimCode(claimCode);
    
    // Create recipient hash (for additional security)
    const recipientHash = crypto.createHash('sha256').update(recipient.toLowerCase().trim()).digest();

    // Create TEAL program
    const tealProgram = createEscrowContractTeal(hashedClaimCode, recipientHash, amount);
    
    // Compile the TEAL program
    const { compiledProgram, hash: programHash } = await compileTealProgram(tealProgram, network);
    
    // Create contract deployment transaction
    const { transaction: deployTxn, txId } = await deployContract(
      compiledProgram, 
      senderAddress, 
      hashedClaimCode, 
      amount,
      network
    );

    // Send notification
    const notificationResult = await sendNotification(recipient, claimCode, amount, message, network);
    
    console.log(`Claim created successfully on ${NETWORK_CONFIGS[network].name}:`);
    console.log(`- Claim code: ${claimCode}`);
    console.log(`- Transaction ID: ${txId}`);
    console.log(`- Program hash: ${programHash}`);
    console.log(`- Notification: ${notificationResult.success ? 'sent' : 'failed'} via ${notificationResult.method}`);

    // Return the response with transaction to be signed
    res.json({
      claimCode,
      transactionId: txId,
      programHash,
      deploymentTransaction: Buffer.from(algosdk.encodeUnsignedTransaction(deployTxn)).toString('base64'),
      notificationSent: notificationResult.success,
      notificationMethod: notificationResult.method
    });

  } catch (error) {
    console.error('Error creating claim:', error);
    res.status(500).json({ 
      error: error.message || 'Internal server error occurred while creating claim' 
    });
  }
});

// API endpoint to submit signed transaction
app.post('/api/submit-transaction', async (req, res) => {
  try {
    const { signedTransaction, network = 'testnet' } = req.body;
    
    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }
    
    if (!signedTransaction) {
      return res.status(400).json({ error: 'Signed transaction is required' });
    }

    const algodClient = createAlgodClient(network);

    // Decode and submit the signed transaction
    const signedTxnBuffer = Buffer.from(signedTransaction, 'base64');
    const txResponse = await algodClient.sendRawTransaction(signedTxnBuffer).do();
    
    // Wait for confirmation
    const confirmedTxn = await algosdk.waitForConfirmation(algodClient, txResponse.txId, 4);
    
    // Get the application ID from the confirmed transaction
    const appId = confirmedTxn['application-index'];
    const appAddress = algosdk.getApplicationAddress(appId);
    
    console.log(`Contract deployed successfully on ${NETWORK_CONFIGS[network].name}:`);
    console.log(`- Application ID: ${appId}`);
    console.log(`- Contract Address: ${appAddress}`);
    console.log(`- Transaction ID: ${txResponse.txId}`);

    res.json({
      success: true,
      transactionId: txResponse.txId,
      applicationId: appId,
      contractAddress: appAddress,
      confirmedRound: confirmedTxn['confirmed-round']
    });

  } catch (error) {
    console.error('Error submitting transaction:', error);
    res.status(500).json({ 
      error: error.message || 'Failed to submit transaction' 
    });
  }
});

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const network = req.query.network || 'testnet';
    
    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }

    // Test Algorand connection
    const algodClient = createAlgodClient(network);
    const status = await algodClient.status().do();
    
    res.json({ 
      status: 'OK', 
      timestamp: new Date().toISOString(),
      algorand: {
        network: NETWORK_CONFIGS[network].name,
        node: NETWORK_CONFIGS[network].algodServer,
        lastRound: status['last-round']
      },
      services: {
        twilio: isValidTwilioConfig ? 'connected' : 'simulated',
        sendgrid: isValidSendGridConfig ? 'connected' : 'simulated'
      }
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      timestamp: new Date().toISOString(),
      error: error.message 
    });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ RandCash API server running on port ${PORT}`);
  console.log(`Supported networks:`);
  Object.entries(NETWORK_CONFIGS).forEach(([key, config]) => {
    console.log(`  - ${config.name}: ${config.algodServer}`);
  });
  console.log(`üìç Health check: http://localhost:${PORT}/api/health`);
  console.log(`üì± Twilio SMS: ${isValidTwilioConfig ? 'Configured' : 'Not configured (will simulate)'}`);
  console.log(`üìß SendGrid Email: ${isValidSendGridConfig ? 'Configured' : 'Not configured (will simulate)'}`);
});