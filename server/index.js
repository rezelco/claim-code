import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import algosdk from 'algosdk';
import crypto from 'crypto';
import axios from 'axios';

const app = express();
const PORT = 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Network configurations
const NETWORK_CONFIGS = {
  testnet: {
    name: 'TestNet',
    algodToken: '',
    algodServer: 'https://testnet-api.4160.nodely.dev',
    algodPort: 443
  },
  mainnet: {
    name: 'MainNet',
    algodToken: '',
    algodServer: 'https://mainnet-api.4160.nodely.dev',
    algodPort: 443
  }
};

// Create Algorand client for specific network
function createAlgodClient(network = 'testnet') {
  const config = NETWORK_CONFIGS[network];
  if (!config) {
    throw new Error(`Unsupported network: ${network}`);
  }
  
  return new algosdk.Algodv2(config.algodToken, config.algodServer, config.algodPort);
}

// Initialize Pica/Resend email service
const picaSecretKey = process.env.PICA_SECRET_KEY;
const picaConnectionKey = process.env.PICA_RESEND_CONNECTION_KEY;
const picaFromEmail = process.env.PICA_FROM_EMAIL;

const isValidPicaConfig = 
  picaSecretKey && 
  picaConnectionKey && 
  picaFromEmail &&
  picaSecretKey !== 'your_pica_secret_key' &&
  picaConnectionKey !== 'your_pica_resend_connection_key' &&
  picaFromEmail !== 'noreply@randcash.app';

if (isValidPicaConfig) {
  console.log('‚úÖ Pica/Resend email service configured');
} else {
  console.log('üìß Pica/Resend not configured - Email notifications will be simulated');
}

// Generate secure random claim code
function generateClaimCode() {
  return crypto.randomBytes(16).toString('hex').toUpperCase();
}

// Hash claim code for smart contract
function hashClaimCode(code) {
  return crypto.createHash('sha256').update(code).digest();
}

// Create PyTEAL-based escrow contract
function createEscrowContractTeal(hashedClaimCode, recipientHash, amount) {
  // This is a simplified TEAL program that would be generated by PyTEAL
  // In production, you'd use PyTEAL to generate this programmatically
  const tealProgram = `#pragma version 6

// This is an escrow contract that holds funds until claimed with correct code
// Global state: 
// - "claim_hash": the hashed claim code
// - "amount": the amount to be claimed
// - "claimed": whether funds have been claimed

txn TypeEnum
int appl // ApplicationCall
==
bnz handle_app_call

// Handle payment transactions
txn TypeEnum
int pay
==
bnz handle_payment

// Reject other transaction types
int 0
return

handle_payment:
// Allow funding the contract
txn Receiver
global CurrentApplicationAddress
==
assert
int 1
return

handle_app_call:
// Check application call method
txn ApplicationArgs 0
byte "claim"
==
bnz handle_claim

txn ApplicationArgs 0
byte "setup"
==
bnz handle_setup

// Default reject
int 0
return

handle_setup:
// Initialize the contract with claim hash
txn ApplicationArgs 1
len
int 32
==
assert

// Store the claim hash
byte "claim_hash"
txn ApplicationArgs 1
app_global_put

// Store the amount
byte "amount"
txn ApplicationArgs 2
btoi
app_global_put

// Mark as not claimed
byte "claimed"
int 0
app_global_put

int 1
return

handle_claim:
// Verify claim code hash
txn ApplicationArgs 1
len
int 32
==
assert

// Check if already claimed
byte "claimed"
app_global_get
int 0
==
assert

// Verify the claim code hash matches
byte "claim_hash"
app_global_get
txn ApplicationArgs 1
==
assert

// Mark as claimed
byte "claimed"
int 1
app_global_put

// Transfer funds to claimer
itxn_begin
int pay
itxn_field TypeEnum
txn Sender
itxn_field Receiver
byte "amount"
app_global_get
itxn_field Amount
itxn_submit

int 1
return`;

  return tealProgram;
}

// Compile TEAL program
async function compileTealProgram(tealSource, network = 'testnet') {
  try {
    const algodClient = createAlgodClient(network);
    
    // Test connection first
    await algodClient.status().do();
    
    const compileResponse = await algodClient.compile(tealSource).do();
    
    if (!compileResponse.result) {
      throw new Error('TEAL compilation failed - no result returned');
    }
    
    return {
      compiledProgram: new Uint8Array(Buffer.from(compileResponse.result, 'base64')),
      hash: compileResponse.hash
    };
  } catch (error) {
    console.error('Error compiling TEAL program:', error);
    throw new Error(`Failed to compile smart contract: ${error.message}`);
  }
}

// Validate Algorand address format
function validateAlgorandAddress(address) {
  if (!address || typeof address !== 'string') {
    throw new Error('Address must be a valid string');
  }
  
  const trimmedAddress = address.trim();
  if (!trimmedAddress) {
    throw new Error('Address cannot be empty');
  }
  
  // Use algosdk's built-in validation
  if (!algosdk.isValidAddress(trimmedAddress)) {
    throw new Error('Invalid Algorand address format');
  }
  
  // Additional validation by attempting to decode the address
  try {
    algosdk.decodeAddress(trimmedAddress);
  } catch (decodeError) {
    throw new Error(`Address validation failed: ${decodeError.message}`);
  }
  
  return trimmedAddress;
}

// Deploy smart contract to Algorand
async function deployContract(compiledProgram, senderAddress, claimHash, amount, network = 'testnet') {
  try {
    console.log('üîç deployContract called with:', {
      compiledProgramLength: compiledProgram?.length,
      senderAddress: senderAddress,
      senderAddressType: typeof senderAddress,
      claimHashLength: claimHash?.length,
      amount: amount,
      network: network
    });
    
    // Validate inputs
    if (!compiledProgram || !(compiledProgram instanceof Uint8Array)) {
      throw new Error('Invalid compiled program - must be Uint8Array');
    }
    
    if (!claimHash || !(claimHash instanceof Uint8Array)) {
      throw new Error('Invalid claim hash - must be Uint8Array');
    }
    
    if (!amount || amount <= 0) {
      throw new Error('Invalid amount - must be positive number');
    }

    // Validate and clean the sender address
    const validatedSenderAddress = validateAlgorandAddress(senderAddress);

    const algodClient = createAlgodClient(network);
    
    // Test connection and get suggested params
    let suggestedParams;
    try {
      suggestedParams = await algodClient.getTransactionParams().do();
      console.log('‚úÖ Successfully fetched transaction parameters');
      
      // Fix genesisHash if it's not a Uint8Array (bug in some algosdk versions)
      if (suggestedParams.genesisHash && !(suggestedParams.genesisHash instanceof Uint8Array)) {
        const hashArray = Object.values(suggestedParams.genesisHash);
        suggestedParams.genesisHash = new Uint8Array(hashArray);
        console.log('üìù Fixed genesisHash format');
      }
      
      // Ensure proper fee is set
      // For app creation, we need higher fees
      if (!suggestedParams.fee || suggestedParams.fee === 0n) {
        // Application creation requires more computation, so use higher fee
        suggestedParams.fee = 2000n; // 0.002 ALGO
        suggestedParams.flatFee = true; // Use flat fee
        console.log('üìù Set transaction fee: 2000 microAlgos for app creation');
      }
    } catch (paramError) {
      console.error('‚ùå Failed to fetch transaction parameters:', paramError);
      throw new Error(`Network connection failed: ${paramError.message}`);
    }
    
    // Validate suggested params - using correct field names from algosdk
    if (!suggestedParams || suggestedParams.fee === undefined || !suggestedParams.firstValid || !suggestedParams.lastValid) {
      console.error('Invalid params structure:', {
        hasSuggestedParams: !!suggestedParams,
        hasFee: suggestedParams?.fee !== undefined,
        hasFirstValid: !!suggestedParams?.firstValid,
        hasLastValid: !!suggestedParams?.lastValid
      });
      throw new Error('Invalid transaction parameters received from network');
    }

    // Create clear program (simple program that always approves)
    const clearProgram = new Uint8Array([0x06, 0x81, 0x01]); // TEAL: #pragma version 6; int 1; return
    
    // Prepare application arguments as Uint8Array
    const appArgs = [
      new TextEncoder().encode('setup'),
      claimHash,
      algosdk.encodeUint64(Math.floor(amount * 1000000)) // Convert ALGO to microAlgos
    ];
    
    // Validate all appArgs are Uint8Array
    appArgs.forEach((arg, index) => {
      if (!(arg instanceof Uint8Array)) {
        throw new Error(`Application argument ${index} is not Uint8Array`);
      }
    });

    console.log('üìù Creating application transaction with:');
    console.log(`  - From: ${validatedSenderAddress}`);
    console.log(`  - Approval program size: ${compiledProgram.length} bytes`);
    console.log(`  - Clear program size: ${clearProgram.length} bytes`);
    console.log(`  - App args count: ${appArgs.length}`);
    console.log(`  - Amount (microAlgos): ${Math.floor(amount * 1000000)}`);
    console.log(`  ‚ö†Ô∏è  Note: Account needs min balance for app creation (0.1 ALGO + 0.1 ALGO per global state var)`);
    
    // Log the suggestedParams to debug
    console.log('üìù Suggested params structure:', {
      flatFee: suggestedParams.flatFee,
      fee: suggestedParams.fee?.toString(),
      firstValid: suggestedParams.firstValid?.toString(),
      lastValid: suggestedParams.lastValid?.toString(),
      genesisID: suggestedParams.genesisID,
      minFee: suggestedParams.minFee?.toString()
    });

    // Log the exact parameters being passed
    console.log('üìù Transaction parameters:', {
      from: validatedSenderAddress,
      fromType: typeof validatedSenderAddress,
      fromValue: validatedSenderAddress,
      hasApprovalProgram: !!compiledProgram,
      hasClearProgram: !!clearProgram,
      appArgsLength: appArgs.length
    });

    // Create application creation transaction with all required parameters
    const appCreateTxn = algosdk.makeApplicationCreateTxnFromObject({
      sender: validatedSenderAddress,  // Changed from 'from' to 'sender'
      suggestedParams: suggestedParams,
      onComplete: algosdk.OnApplicationComplete.NoOpOC,
      approvalProgram: compiledProgram,
      clearProgram: clearProgram,
      numLocalInts: 0,
      numLocalByteSlices: 0,
      numGlobalInts: 2, // amount, claimed
      numGlobalByteSlices: 1, // claim_hash
      appArgs: appArgs
      // Remove undefined fields as they might cause issues
    });

    console.log('‚úÖ Application transaction created successfully');
    
    // Get transaction ID
    let txId;
    try {
      txId = appCreateTxn.txID();
      console.log(`  - Transaction ID: ${txId}`);
      console.log(`  - Transaction ID type: ${typeof txId}`);
    } catch (txIdError) {
      console.error('‚ùå Error getting transaction ID:', txIdError);
      throw new Error('Failed to get transaction ID from created transaction');
    }

    return {
      transaction: appCreateTxn,
      txId: txId
    };
  } catch (error) {
    console.error('‚ùå Error creating contract deployment transaction:', error);
    
    // Provide more specific error information
    if (error.message.includes('Address must not be null')) {
      throw new Error('Invalid sender address provided to transaction creation');
    } else if (error.message.includes('suggestedParams')) {
      throw new Error('Failed to get valid network parameters - check network connectivity');
    } else if (error.message.includes('approvalProgram')) {
      throw new Error('Invalid approval program - compilation may have failed');
    } else {
      throw new Error(`Failed to create contract deployment transaction: ${error.message}`);
    }
  }
}

// Send email notification via Pica/Resend
async function sendEmailNotification(recipient, claimCode, amount, message, network = 'testnet') {
  const networkName = NETWORK_CONFIGS[network].name;
  
  try {
    if (!isValidPicaConfig) {
      const notificationMessage = `You've received ${amount} ALGO on RandCash (${networkName})! ${message ? `Message: "${message}"` : ''} Use claim code: ${claimCode} to claim your funds.`;
      console.log(`üìß [SIMULATED EMAIL] To: ${recipient}: ${notificationMessage}`);
      return { success: true, method: 'email_simulation' };
    }

    const emailData = {
      from: `RandCash <${picaFromEmail}>`,
      to: recipient,
      subject: `You've received ${amount} ALGO on RandCash (${networkName})!`,
      html: `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
          <div style="text-align: center; margin-bottom: 30px;">
            <div style="display: inline-block; width: 60px; height: 60px; background: linear-gradient(135deg, #2563eb, #4f46e5); border-radius: 12px; display: flex; align-items: center; justify-content: center; margin-bottom: 16px;">
              <span style="color: white; font-size: 24px;">üí∏</span>
            </div>
            <h1 style="color: #1f2937; margin: 0; font-size: 28px; font-weight: bold;">You've received ${amount} ALGO!</h1>
          </div>
          
          <div style="background: #f8fafc; border-radius: 12px; padding: 24px; margin: 24px 0;">
            <p style="color: #374151; font-size: 16px; line-height: 1.6; margin: 0 0 16px 0;">
              Someone sent you cryptocurrency using RandCash on Algorand ${networkName}.
            </p>
            ${message ? `
              <div style="background: white; border-radius: 8px; padding: 16px; margin: 16px 0; border-left: 4px solid #2563eb;">
                <p style="color: #6b7280; font-size: 14px; margin: 0 0 4px 0; font-weight: 600;">Message:</p>
                <p style="color: #1f2937; font-size: 16px; margin: 0; font-style: italic;">"${message}"</p>
              </div>
            ` : ''}
          </div>
          
          <div style="background: linear-gradient(135deg, #eff6ff, #dbeafe); border-radius: 12px; padding: 24px; margin: 24px 0; text-align: center;">
            <p style="color: #1e40af; font-size: 16px; font-weight: 600; margin: 0 0 12px 0;">Your Claim Code:</p>
            <div style="background: white; border-radius: 8px; padding: 16px; margin: 12px 0; border: 2px solid #2563eb;">
              <p style="font-family: 'Courier New', monospace; font-size: 24px; font-weight: bold; color: #1f2937; margin: 0; letter-spacing: 2px;">
                ${claimCode}
              </p>
            </div>
            <p style="color: #1e40af; font-size: 14px; margin: 12px 0 0 0;">
              Keep this code safe - you'll need it to claim your funds!
            </p>
          </div>
          
          <div style="text-align: center; margin: 32px 0;">
            <a href="https://randcash.app" style="display: inline-block; background: linear-gradient(135deg, #2563eb, #4f46e5); color: white; text-decoration: none; padding: 14px 28px; border-radius: 8px; font-weight: 600; font-size: 16px;">
              Claim Your Funds ‚Üí
            </a>
          </div>
          
          <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-top: 32px;">
            <p style="color: #6b7280; font-size: 12px; text-align: center; margin: 0;">
              Network: Algorand ${networkName} ‚Ä¢ Powered by RandCash
            </p>
          </div>
        </div>
      `,
      text: `You've received ${amount} ALGO on RandCash (${networkName})!

${message ? `Message: "${message}"` : ''}

Your claim code: ${claimCode}

Visit RandCash to claim your funds by entering this code and connecting your wallet.

Network: Algorand ${networkName}`,
      tags: [
        { name: 'service', value: 'randcash' },
        { name: 'type', value: 'claim_notification' },
        { name: 'network', value: network }
      ]
    };

    const response = await axios.post('https://api.picaos.com/v1/passthrough/email', emailData, {
      headers: {
        'Content-Type': 'application/json',
        'x-pica-secret': picaSecretKey,
        'x-pica-connection-key': picaConnectionKey,
        'x-pica-action-id': 'conn_mod_def::GC4q4JE4I28::x8Elxo0VRMK1X-uH1C3NeA',
      }
    });

    console.log(`‚úÖ Email sent successfully! ID: ${response.data.id}`);
    return { success: true, method: 'email', emailId: response.data.id };

  } catch (error) {
    console.error('Error sending email:', error.response?.data || error.message);
    // Don't fail the entire transaction if notification fails
    return { 
      success: false, 
      error: error.response?.data?.message || error.message, 
      method: 'email' 
    };
  }
}

// Helper function to safely extract and convert application ID to number
function extractApplicationId(confirmedTxn) {
  // Try multiple possible locations for the app ID
  let rawAppId = confirmedTxn['application-index'] || 
                 confirmedTxn['applicationIndex'] || 
                 confirmedTxn.applicationIndex ||
                 confirmedTxn['app-id'] ||
                 confirmedTxn.appId;
  
  // Check if it's nested in txn or other objects
  if (!rawAppId && confirmedTxn.txn) {
    rawAppId = confirmedTxn.txn['application-index'] || 
               confirmedTxn.txn.applicationIndex ||
               confirmedTxn.txn['app-id'] ||
               confirmedTxn.txn.appId;
  }
  
  console.log('üìù Raw application index:', rawAppId, 'type:', typeof rawAppId);
  
  // Ensure appId is a proper number - handle all possible types
  let appId = null;
  
  if (rawAppId !== null && rawAppId !== undefined) {
    if (typeof rawAppId === 'string') {
      const parsed = parseInt(rawAppId, 10);
      if (!isNaN(parsed) && parsed > 0) {
        appId = parsed;
      }
    } else if (typeof rawAppId === 'bigint') {
      const converted = Number(rawAppId);
      if (Number.isSafeInteger(converted) && converted > 0) {
        appId = converted;
      }
    } else if (typeof rawAppId === 'number') {
      if (Number.isInteger(rawAppId) && rawAppId > 0) {
        appId = rawAppId;
      }
    } else if (typeof rawAppId === 'object' && rawAppId !== null) {
      // Handle case where rawAppId might be an object with numeric properties
      // This prevents objects from being passed through
      console.log('‚ö†Ô∏è Application ID is an object, attempting to extract numeric value:', rawAppId);
      
      // Try to find a numeric property that could be the app ID
      const possibleKeys = ['value', 'id', 'appId', 'applicationId', 'index'];
      for (const key of possibleKeys) {
        if (rawAppId[key] !== undefined) {
          const candidate = rawAppId[key];
          if (typeof candidate === 'number' && Number.isInteger(candidate) && candidate > 0) {
            appId = candidate;
            console.log(`‚úÖ Extracted app ID from object.${key}: ${appId}`);
            break;
          } else if (typeof candidate === 'string') {
            const parsed = parseInt(candidate, 10);
            if (!isNaN(parsed) && parsed > 0) {
              appId = parsed;
              console.log(`‚úÖ Extracted and parsed app ID from object.${key}: ${appId}`);
              break;
            }
          }
        }
      }
      
      // If we still don't have a valid appId, this is an error
      if (appId === null) {
        console.error('‚ùå Could not extract valid app ID from object:', rawAppId);
      }
    }
  }
  
  console.log('üìù Parsed application ID:', appId, 'type:', typeof appId);
  
  return appId;
}

// Root endpoint to confirm server is running
app.get('/', (req, res) => {
  res.json({ 
    message: 'RandCash API Server is running!',
    version: '1.0.0',
    endpoints: [
      'GET /api/health',
      'POST /api/create-claim',
      'POST /api/submit-transaction'
    ],
    timestamp: new Date().toISOString()
  });
});

// API endpoint to create claim
app.post('/api/create-claim', async (req, res) => {
  try {
    const { amount, recipient, message, senderAddress, network = 'testnet' } = req.body;

    console.log(`üì• Received create-claim request:`, {
      amount,
      recipient: recipient ? `${recipient.substring(0, 5)}...` : 'undefined',
      senderAddress: senderAddress ? `${senderAddress.substring(0, 8)}...` : 'undefined',
      senderAddressType: typeof senderAddress,
      senderAddressValue: senderAddress,
      network,
      hasMessage: !!message
    });

    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }

    // Validate input
    if (!amount || amount <= 0) {
      return res.status(400).json({ error: 'Invalid amount' });
    }
    
    if (!recipient || !recipient.trim()) {
      return res.status(400).json({ error: 'Recipient email is required' });
    }
    
    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(recipient.trim())) {
      return res.status(400).json({ error: 'Please provide a valid email address' });
    }
    
    // Validate sender address using our helper function
    let validatedSenderAddress;
    try {
      validatedSenderAddress = validateAlgorandAddress(senderAddress);
    } catch (addressError) {
      return res.status(400).json({ error: `Invalid sender address: ${addressError.message}` });
    }

    // Additional validation for MainNet
    if (network === 'mainnet' && amount > 10) {
      return res.status(400).json({ error: 'Maximum amount on MainNet is 10 ALGO for safety' });
    }

    console.log(`‚úÖ Creating claim for ${amount} ALGO from ${validatedSenderAddress} to ${recipient} on ${NETWORK_CONFIGS[network].name}`);

    // Generate claim code and hash it
    const claimCode = generateClaimCode();
    const hashedClaimCode = hashClaimCode(claimCode);
    
    // Create recipient hash (for additional security)
    const recipientHash = crypto.createHash('sha256').update(recipient.toLowerCase().trim()).digest();

    // Create TEAL program
    console.log('üìù Creating TEAL program...');
    const tealProgram = createEscrowContractTeal(hashedClaimCode, recipientHash, amount);
    
    // Compile the TEAL program
    console.log('üî® Compiling TEAL program...');
    const { compiledProgram, hash: programHash } = await compileTealProgram(tealProgram, network);
    console.log(`‚úÖ TEAL compilation successful, hash: ${programHash}`);
    
    // Create contract deployment transaction with validated sender address
    console.log('üìã Creating deployment transaction...');
    const { transaction: deployTxn, txId } = await deployContract(
      compiledProgram, 
      validatedSenderAddress, 
      hashedClaimCode, 
      amount,
      network
    );
    console.log(`‚úÖ Deployment transaction created: ${txId}`);

    console.log(`üéâ Deployment transaction created successfully on ${NETWORK_CONFIGS[network].name}:`);
    console.log(`- Claim code: ${claimCode}`);
    console.log(`- Transaction ID: ${txId}`);
    console.log(`- Program hash: ${programHash}`);
    console.log(`- Email will be sent after contract deployment`);

    // Return the response with transaction to be signed
    // Include claim details for email to be sent after deployment
    res.json({
      claimCode,
      transactionId: txId,
      programHash,
      deploymentTransaction: Buffer.from(algosdk.encodeUnsignedTransaction(deployTxn)).toString('base64'),
      // Include details needed for sending email after deployment
      claimDetails: {
        recipient,
        amount,
        message,
        network
      }
    });

  } catch (error) {
    console.error('‚ùå Error creating claim:', error);
    res.status(500).json({ 
      error: error.message || 'Internal server error occurred while creating claim' 
    });
  }
});

// API endpoint to submit signed transaction
app.post('/api/submit-transaction', async (req, res) => {
  try {
    const { signedTransaction, network = 'testnet', claimDetails } = req.body;
    
    console.log(`üì• Received submit-transaction request for ${NETWORK_CONFIGS[network]?.name || network}`);
    
    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }
    
    if (!signedTransaction) {
      return res.status(400).json({ error: 'Signed transaction is required' });
    }

    const algodClient = createAlgodClient(network);

    // Decode and submit the signed transaction
    console.log('üì§ Submitting signed transaction to network...');
    const signedTxnBuffer = Buffer.from(signedTransaction, 'base64');
    
    // Log transaction details before submission
    console.log(`üìù Transaction buffer length: ${signedTxnBuffer.length} bytes`);
    
    let txResponse;
    try {
      txResponse = await algodClient.sendRawTransaction(signedTxnBuffer).do();
      console.log(`‚úÖ Transaction submitted successfully`);
      console.log(`   - Full response:`, JSON.stringify(txResponse));
      console.log(`   - Response type:`, typeof txResponse);
      console.log(`   - Response keys:`, Object.keys(txResponse || {}));
      console.log(`   - Transaction ID: ${txResponse?.txId}`);
      console.log(`   - Transaction ID type: ${typeof txResponse?.txId}`);
      console.log(`   - Transaction ID length: ${txResponse?.txId?.length}`);
    } catch (submitError) {
      console.error('‚ùå Failed to submit transaction:', submitError);
      
      // Try to decode the transaction to see what we're sending
      try {
        const decodedTxn = algosdk.decodeSignedTransaction(signedTxnBuffer);
        console.error('Decoded transaction:', {
          txnType: decodedTxn.txn.type,
          sender: decodedTxn.txn.sender,
          fee: decodedTxn.txn.fee,
          hasSignature: !!decodedTxn.sig
        });
      } catch (decodeError) {
        console.error('Could not decode transaction:', decodeError.message);
      }
      
      throw new Error(`Transaction submission failed: ${submitError.message}`);
    }
    
    // Validate transaction ID - check different possible response formats
    // Note: algosdk v3 returns 'txid' (lowercase) not 'txId'
    const txId = txResponse?.txid || txResponse?.txId || txResponse?.transactionID;
    if (!txId) {
      console.error('‚ùå No transaction ID found in response:', txResponse);
      throw new Error('No transaction ID returned from submission');
    }
    
    // Normalize to use txId for consistency
    txResponse.txId = txId;
    console.log(`üìù Transaction ID found: ${txId}`);
    
    // Wait for confirmation with more rounds and better error handling
    console.log('‚è≥ Waiting for transaction confirmation...');
    let confirmedTxn;
    let lastStatus = '';
    
    try {
      // Simplified wait logic - just use the built-in algosdk function
      console.log('Using algosdk.waitForConfirmation with 15 rounds...');
      confirmedTxn = await algosdk.waitForConfirmation(algodClient, txResponse.txId, 15);
      console.log(`‚úÖ Transaction confirmed in round ${confirmedTxn['confirmed-round']}`);
      
    } catch (waitError) {
      console.error('‚ö†Ô∏è Standard wait failed, trying manual check...');
      
      // Manual check if algosdk.waitForConfirmation fails
      try {
        const txInfo = await algodClient.pendingTransactionInformation(txResponse.txId).do();
        if (txInfo['confirmed-round']) {
          console.log(`‚úÖ Transaction was actually confirmed in round ${txInfo['confirmed-round']}`);
          confirmedTxn = txInfo;
        } else {
          // Try to get current node status for better error message
          let currentRound = 'unknown';
          try {
            const status = await algodClient.status().do();
            currentRound = status['last-round'];
          } catch (statusError) {
            console.error('Could not get node status:', statusError.message);
          }
          
          const poolError = txInfo['pool-error'] || 'none';
          throw new Error(`Transaction not confirmed. Current round: ${currentRound}, Pool error: ${poolError}, Wait error: ${waitError.message}`);
        }
      } catch (infoError) {
        throw new Error(`Transaction confirmation failed: ${waitError.message}. Could not get transaction info: ${infoError.message}`);
      }
    }
    
    // Debug: log the entire confirmed transaction structure
    console.log('üìù Confirmed transaction keys:', Object.keys(confirmedTxn));
    console.log('üìù Confirmed transaction sample:', JSON.stringify(confirmedTxn, (key, value) => 
      typeof value === 'bigint' ? value.toString() : value
    ).substring(0, 500) + '...');
    
    // Use the helper function to safely extract application ID
    let appId = extractApplicationId(confirmedTxn);
    
    if (!appId || appId <= 0 || !Number.isInteger(appId)) {
      // Try to get the transaction info directly from the network
      console.log('‚ö†Ô∏è Application ID not found in confirmation, trying to fetch transaction details...');
      try {
        const networkTxInfo = await algodClient.pendingTransactionInformation(txResponse.txId).do();
        console.log('üìù Network transaction info keys:', Object.keys(networkTxInfo));
        
        appId = extractApplicationId(networkTxInfo);
        
        if (appId && appId > 0 && Number.isInteger(appId)) {
          console.log('‚úÖ Found application ID from network:', appId);
        } else {
          throw new Error(`Could not find valid application ID in transaction. Confirmed transaction keys: ${Object.keys(confirmedTxn)}. Network transaction keys: ${Object.keys(networkTxInfo)}`);
        }
      } catch (fetchError) {
        throw new Error(`Invalid application ID: ${appId}. Could not fetch from network: ${fetchError.message}`);
      }
    }
    
    // Ensure appId is definitely a number before using it
    if (typeof appId !== 'number' || !Number.isInteger(appId) || appId <= 0) {
      throw new Error(`Application ID must be a positive integer, got: ${appId} (type: ${typeof appId})`);
    }
    
    // Convert the Address object to string before sending to frontend
    const appAddress = algosdk.getApplicationAddress(appId);
    const contractAddressString = appAddress.toString();
    
    console.log(`üéâ Contract deployed successfully on ${NETWORK_CONFIGS[network].name}:`);
    console.log(`- Application ID: ${appId}`);
    console.log(`- Contract Address: ${contractAddressString}`);
    console.log(`- Transaction ID: ${txResponse.txId}`);
    console.log(`- Confirmed Round: ${confirmedTxn['confirmed-round']}`);

    // Send email notification if claim details are provided
    let notificationResult = { success: false, method: 'not_attempted' };
    if (claimDetails) {
      console.log('üìß Sending email notification after successful deployment...');
      try {
        notificationResult = await sendEmailNotification(
          claimDetails.recipient,
          claimDetails.claimCode,
          claimDetails.amount,
          claimDetails.message,
          network
        );
        console.log(`‚úÖ Email notification: ${notificationResult.success ? 'sent' : 'failed'}`);
      } catch (emailError) {
        console.error('‚ùå Failed to send email notification:', emailError);
        // Don't fail the whole request if email fails - contract is already deployed
      }
    }

    res.json({
      success: true,
      transactionId: txResponse.txId,
      applicationId: appId,
      contractAddress: contractAddressString, // Send as string instead of Address object
      confirmedRound: confirmedTxn['confirmed-round'],
      notificationSent: notificationResult.success,
      notificationMethod: notificationResult.method
    });

  } catch (error) {
    console.error('‚ùå Error submitting transaction:', error);
    res.status(500).json({ 
      error: error.message || 'Failed to submit transaction' 
    });
  }
});

// Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const network = req.query.network || 'testnet';
    
    // Validate network
    if (!NETWORK_CONFIGS[network]) {
      return res.status(400).json({ error: 'Invalid network specified' });
    }

    // Test Algorand connection
    const algodClient = createAlgodClient(network);
    const status = await algodClient.status().do();
    
    res.json({ 
      status: 'OK', 
      timestamp: new Date().toISOString(),
      algorand: {
        network: NETWORK_CONFIGS[network].name,
        node: NETWORK_CONFIGS[network].algodServer,
        lastRound: status['last-round']
      },
      services: {
        email: isValidPicaConfig ? 'connected' : 'simulated'
      }
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      timestamp: new Date().toISOString(),
      error: error.message 
    });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ RandCash API server running on port ${PORT}`);
  console.log(`Supported networks:`);
  Object.entries(NETWORK_CONFIGS).forEach(([key, config]) => {
    console.log(`  - ${config.name}: ${config.algodServer}`);
  });
  console.log(`üìç Health check: http://localhost:${PORT}/api/health`);
  console.log(`üìß Pica/Resend Email: ${isValidPicaConfig ? 'Configured' : 'Not configured (will simulate)'}`);
});